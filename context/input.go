// Copyright 2014 beego Author. All Rights Reserved.
// 2015 (c) Dmitriy Blokhin (sv.dblokhin@gmail.com), www.webjinn.ru

package context

import (
	"errors"
	"net/http"
	"strconv"
	"strings"
	"io/ioutil"
	"bytes"
	"encoding/json"
)

// Input operates the http request header, data, cookie and body.
// it also contains router params and current session.
type Input struct {
	request *http.Request
}

// NewInput return BeegoInput generated by http.Request.
func NewInput(req *http.Request) *Input {
	return &Input{
		request: req,
	}
}

// Request возвращает *http.Request
func (input *Input) Request() *http.Request {
	return input.request
}

// Protocol returns request protocol name, such as HTTP/1.1 .
func (input *Input) Protocol() string {
	return input.request.Proto
}

// Uri returns full request url with query string, fragment.
func (input *Input) Uri() string {
	return input.request.RequestURI
}

// Url returns request url path (without query string, fragment).
func (input *Input) Url() string {
	return input.request.URL.Path
}

// Site returns base site url as scheme://domain type.
func (input *Input) Site() string {
	return input.Scheme() + "://" + input.Domain()
}

// Scheme returns request scheme as "http" or "https".
func (input *Input) Scheme() string {
	if input.request.URL.Scheme != "" {
		return input.request.URL.Scheme
	}
	if input.request.TLS == nil {
		return "http"
	}
	return "https"
}

// Domain returns host name.
// Alias of Host method.
func (input *Input) Domain() string {
	return input.Host()
}

// Host returns host name.
// if no host info in request, return localhost.
func (input *Input) Host() string {
	if input.request.Host != "" {
		hostParts := strings.Split(input.request.Host, ":")
		if len(hostParts) > 0 {
			return hostParts[0]
		}
		return input.request.Host
	}
	return "localhost"
}

// Method returns http request method.
func (input *Input) Method() string {
	return input.request.Method
}

// Is returns boolean of this request is on given method, such as Is("POST").
func (input *Input) Is(method string) bool {
	return input.Method() == method
}

// Is this a GET method request?
func (input *Input) IsGet() bool {
	return input.Is("GET")
}

// Is this a POST method request?
func (input *Input) IsPost() bool {
	return input.Is("POST")
}

// Is this a Head method request?
func (input *Input) IsHead() bool {
	return input.Is("HEAD")
}

// Is this a OPTIONS method request?
func (input *Input) IsOptions() bool {
	return input.Is("OPTIONS")
}

// Is this a PUT method request?
func (input *Input) IsPut() bool {
	return input.Is("PUT")
}

// Is this a DELETE method request?
func (input *Input) IsDelete() bool {
	return input.Is("DELETE")
}

// Is this a PATCH method request?
func (input *Input) IsPatch() bool {
	return input.Is("PATCH")
}

// IsAjax returns boolean of this request is generated by ajax.
func (input *Input) IsAjax() bool {
	return input.Header("X-Requested-With") == "XMLHttpRequest"
}

// IsSecure returns boolean of this request is in https.
func (input *Input) IsSecure() bool {
	return input.Scheme() == "https"
}

// IsWebsocket returns boolean of this request is in webSocket.
func (input *Input) IsWebsocket() bool {
	return input.Header("Upgrade") == "websocket"
}

// IsUpload returns boolean of whether file uploads in this request or not..
func (input *Input) IsUpload() bool {
	return strings.Contains(input.Header("Content-Type"), "multipart/form-data")
}

// IP returns request client ip.
// if in proxy, return first proxy id.
// if error, return 127.0.0.1.
func (input *Input) IP() string {
	ips := input.Proxy()
	if len(ips) > 0 && ips[0] != "" {
		rip := strings.Split(ips[0], ":")
		return rip[0]
	}
	ip := strings.Split(input.request.RemoteAddr, ":")
	if len(ip) > 0 {
		if ip[0] != "[" {
			return ip[0]
		}
	}
	return "127.0.0.1"
}

// Proxy returns proxy client ips slice.
func (input *Input) Proxy() []string {
	if ips := input.Header("X-Forwarded-For"); ips != "" {
		return strings.Split(ips, ",")
	}
	return []string{}
}

// Referer returns http referer header.
func (input *Input) Referer() string {
	return input.Header("Referer")
}

// Refer returns http referer header.
func (input *Input) Refer() string {
	return input.Referer()
}

// SubDomains returns sub domain string.
// if aa.bb.domain.com, returns aa.bb .
func (input *Input) SubDomains() string {
	parts := strings.Split(input.Host(), ".")
	if len(parts) >= 3 {
		return strings.Join(parts[:len(parts)-2], ".")
	}
	return ""
}

// Port returns request client port.
// when error or empty, return 80.
func (input *Input) Port() int {
	parts := strings.Split(input.request.Host, ":")
	if len(parts) == 2 {
		port, _ := strconv.Atoi(parts[1])
		return port
	}
	return 80
}

// UserAgent returns request client user agent string.
func (input *Input) UserAgent() string {
	return input.Header("User-Agent")
}

// Query returns input data item string by a given string.
func (input *Input) Query(key string) string {
	if input.request.Form == nil {
		input.request.ParseForm()
	}
	return input.request.Form.Get(key)
}

// Header returns request header item string by a given string.
// if non-existed, return empty string.
func (input *Input) Header(key string) string {
	return input.request.Header.Get(key)
}

// Cookie returns request cookie item string by a given key.
// if non-existed, return empty string.
func (input *Input) Cookie(key string) string {
	ck, err := input.request.Cookie(key)
	if err != nil {
		return ""
	}
	return ck.Value
}

// CopyBody returns the raw request body data as bytes.
func (input *Input) CopyBody() []byte {
	body, _ := ioutil.ReadAll(input.request.Body)
	input.request.Body.Close()
	bf := bytes.NewBuffer(body)
	input.request.Body = ioutil.NopCloser(bf)

	return body
}

// JsonPayload quick function for unmarshaling JSON payload from RequestBody
func (input *Input) JSONPayload(jsonStruct interface{}) error {
	return json.Unmarshal(input.CopyBody(), jsonStruct)
}

// parseForm or parseMultiForm based on Content-type
func (input *Input) ParseFormOrMulitForm(maxMemory int64) error {
	// Parse the body depending on the content type.
	if strings.Contains(input.Header("Content-Type"), "multipart/form-data") {
		if err := input.request.ParseMultipartForm(maxMemory); err != nil {
			return errors.New("Error parsing request body:" + err.Error())
		}
	} else if err := input.request.ParseForm(); err != nil {
		return errors.New("Error parsing request body:" + err.Error())
	}
	return nil
}
